---
layout: post
title: Writing a 2048 clone in elm
tags: 
    - unramblings
    - programming
toc: true
comments: true
---


Several weeks ago, I, along with the rest of the internet, discovered [2048](http://gabrielecirulli.github.io/2048/), a fascinating one player game based on powers of two. Although it has a simple premise, the game requires a complex set of carefully thought out non-linear strategies to win, in a way that makes it comparable to a Rubik's Cube, or the two player game Go.

There are many interesting mathematical questions one could ask about the game, both trivial and non-trivial. For example:

1. What is the least number of moves required to win?
1. What is the lowest possible score when the game is won?
1. What is the highest number of moves that can be carried out before a win?
1. What is the lowest possible score when the game is lost?
1. Is a win always guaranteed?

I intend to try to tackle some of these in another post. 

For now, I have applied my new found love for functional programming and created a clone of 2048 in elm. [Elm](http://elm-lang.org/) is a programming language based on Haskell that uses [Functional Reactive Programming](http://en.wikipedia.org/wiki/Functional_reactive_programming) to enable the creation of interactive applications, while keeping the language functional. 

Elm compiles to HTML, CSS and Javacript, and so is very easy to deploy &mdash; as a demonstration of this I have embedded the final product of this project below. Start a new game and give it a try!

<center><iframe style="border: none; width: 560px; height: 680px;" src="http://scrambledeggsontoast.github.io/2048-elm/build/"></iframe></center>

I decided to write up the project to serve as a resource and a tutorial of sorts for those trying to get into FRP or elm. I am still learning about these topics myself, so if you notice anything that has been done in a suboptimal way do let me know. Also, this is the first time I have written a post like this of any significant length, so feedback with regards to that is also welcome.

The project [is on GitHub](https://github.com/ScrambledEggsOnToast/2048-elm). Feel free to submit pull requests if you want to fix any bugs, or indeed for any other appropriate reason. 

## Prerequisites and references

I expect you to at least have a working knowledge of functional programming, and preferably in the context of Haskell. If you do not, [Learn You a Haskell for Great Good!](http://learnyouahaskell.com/) can be [read online](http://learnyouahaskell.com/chapters) and is an excellent beginner's guide. If you are not comfortable with functors, monads, etc., you should still be able to follow this tutorial. Those concepts are not used in this project, and are not explicitly used in elm in general.

I don't expect you to have used elm before. The general syntax in elm is very similar to that of Haskell, with a few key differences. Of importance is the fact that while in Haskell ``::`` is the 'has type of' symbol, and ``:`` is the cons operator, in elm ``:`` is the 'has type of' symbol, and ``::`` is the cons operator. Also, the function application operator in elm is ``<|``, not ``$`` as it is in Haskell. I will describe other differences as we encounter them. A useful syntax reference can be found [here](http://elm-lang.org/learn/Syntax.elm). 

The main difference in programming style between elm and Haskell is that elm uses *signals*, which are values that change with time. I will explain how these work and how to use them in the next section.

A key feature of elm is that an elm file can be compiled to a *component*, which can be embedded into an HTML document, and can communicate with Javascipt via *ports*. We will use take advantage of this in our project, but it does not matter if you are unfamiliar with HTML and Javascript, as they are not the focus.

If you have installed ``cabal-install``, elm can be installed with ``cabal install elm``. Compiling elm files is as easy as using ``elm Main.elm`` to generate a file ``build/Main.html``, which can be opened in a web browser. 

## About signals
Signals in elm are values that change with time. They are event-based, meaning changes in signals are discrete, and do not have to happen at regular intervals. 

Note that here *changes* will not necessarily mean a change in the value held by the signal. For instance suppose a signal holds the value 2, and then an event occurs that makes its value 2. The value held by the signal has not changed, but an event has still been recorded by it.

Suppose we have a signal ``signal`` that holds the value ``"foo"``. We say that ``signal`` has type ``Signal String``. After five seconds an event arrives on ``signal``, changing its value to ``"bar"``. 

Now suppose we have a function ``question`` that appends ``"?"`` to a string. We cannot apply ``question`` directly to ``signal`` because ``question`` takes values that are strings, and ``signal`` is a signal of strings. How then do we apply a function to a signal?

The answer is to use ``lift``, a function provided by elm. ``lift`` takes a function of type ``a -> b`` and a signal of type ``Signal a``, and returns a signal of type ``Signal b``. This signal is what you might expect: for each event in the signal of type ``Signal a``, the function of type ``a -> b`` is applied to the value of the signal after that event, and the result of this is made the value of a new event in the signal of type ``Signal b``.

So suppose we define a signal ``signalQuestioned = lift question signal``. We then have that the value held now by ``signalQuestioned`` is ``"foo?"``, and in five seconds an event will arrive on the signal that will change the value it holds to ``"bar?"``.

Elm provides symbolic operators to make this easier to read and type. ``lift question signal`` is equivalent to ``question <~ signal``, read as "``signal`` fed into ``question``". If we have a function that takes more than one parameter we can use ``~`` to feed a series of signals of the parameters into the function as follows: ``function <~ signal1 ~ signal2 ~ signal3``. For more information on how this works, see
[here](http://elm-lang.org/blog/announce/0.7.elm#do-you-even-lift).

## Definition of the game

The board on which 2048 is played is a 4 by 4 grid of tiles. Tiles can either be empty, or contain an integer number that is a power of two. The initial board contains two random tiles in random positions. Each of these tiles has a 90% probability of being a 2, and a 10% probability of being a 4.

At any time, the player has the option to slide all of the tiles in the grid in one of four directions: up, down, left or right. The tiles slide naturally as expected, filling empty tiles with tiles that contain numbers, but also have an additional behaviour. If there are two adjacent non-empty tiles (in the direction of the slide) that hold the same value, then those two tiles merge together, forming a new tile whose value is the sum of the original two. The new tile's value is
added to the score. If there are more than two adjacent non-empty tiles holding the same value, this pairing is prioritised to be between those most in the direction specified &mdash; so sliding a grid with a row \\([2,2,2,8]\\) to the left would result in \\([4,2,8,0]\\), whereas sliding it to the right would result in \\([0,2,4,8]\\). 

After each slide, a new random tile (again being a 2 with 90% probability, and being a 4 with 10% probability) is placed in one of the remaining empty tile positions.

The game ends in one of two ways. If one of the tiles in the grid has the value 2048, then the game is won. If the grid is full of tiles, and no slides in any direction will alter the grid any further, then the game is lost. The win condition holds precedence over the loss condition.

## To the text editor!

We've gone through some basic FRP concepts and have defined the game we're going to make, and now it's finally time to start coding.

### A couple of utility functions

There are quite a few function in Haskell's standard libraries that aren't implemented in elm. Of these, there are two we are going to need to use. These functions aren't specific enough to apply to just one part of the project, so we'll create a file ``Utils.elm`` that defines them (``.elm`` is the standard file extension for elm files). 

We'll start the file with a module definition: 

{% highlight haskell %}
-- Utils.elm
module Utils where
{% endhighlight %}

Note that every elm file must start this same way, and the name of the module must be identical to that of the file.

#### List index operator

Elm has no built in operator for extracting elements from a list by their index. We will define one ourselves, using elm's [case notation](http://elm-lang.org/learn/Syntax.elm#conditionals).

{% highlight haskell %}
infixl 9 !
(!) : [a] -> Int -> a -- the nth element of a list
l ! n = case (l,n) of
    (l,0) -> head l
    ((x::xs),n) -> xs ! (n-1)
{% endhighlight %}

This should be easy to follow. The 0th element of a list is its head. The nth element of a list is the (n-1)th element of its tail. 

Note that this is a little sloppy &mdash; we'd like to be able to throw errors for situations when for example an index is out of bounds, but this is beyond the scope of this tutorial. Fortunately, this implementation will satisfy the needs of our project.

#### List of lists transposition

The transpose of a list of lists ``ll`` is a list of lists ``llt`` defined as follows: if an element is in the ith place of the jth list in ``ll``, then it is in the jth place of the ith list in ``llt``. 

For example, the transpose of 

\\[
\begin{array}{rcccl}
[[ & 1, & 2, & 3 & ], \\\\
 [ & 4, & 5, & 6 & ], \\\\
 [ & 7, & 8, & 9 & ]] \\\\
\end{array}
\\]

is equal to 

\\[
\begin{array}{rcccl}
[[ & 1, & 4, & 7 & ], \\\\
 [ & 2, & 5, & 8 & ], \\\\
 [ & 3, & 6, & 9 & ]] \\\\
\end{array}
\\]

You can view this as a reflection along the diagonal.

Again, although Haskell provides a ``transpose`` function, when using elm we will need to make one ourselves:

{% highlight haskell %}
transpose : [[a]] -> [[a]] -- transposes a list of lists
transpose ll = case ll of
    ((x::xs)::xss) -> (x :: (map head xss)) :: transpose (xs :: (map tail xss))
    otherwise -> []
{% endhighlight %}

This is only slightly harder to understand than the list index operator &mdash; see if you can work it out. Again, this implementation ignores a lot of potentially error prone situations, but it will suffice for our needs.
### Input Model

When I refer to the input, I mean all of the information that causes the code to run differently each time. So for example input is not just limited to using the keyboard, but can also mean a source of random data. 

Our first task is to model the input for the game. We create a new file ``InputModel.elm`` and define its module:

{% highlight haskell %}
-- InputModel.elm
module InputModel where
{% endhighlight %}

We will need to make use of both keyboard input and a source of random numbers, so we import their respective libraries:

{% highlight haskell %}
import Keyboard
import Random
{% endhighlight %}

There are three inputs in the game: 

1. The controls that the player changes, i.e. the direction for a slide.
1. The state of the button to initiate a new game.
1. Two pairs of two random floats, one for choosing a random tile value, and the other for choosing a random tile location. We need two pairs for the beginning of a new game, when we place two tiles.

First we define a new data type for the direction of a slide:

{% highlight haskell %}
data Direction = Up | Down | Left | Right | None -- the direction to shift the grid
{% endhighlight %}

We need a way to store all of the input information in a single data structure. One of elm's features is its implementation of records, which are essentially easily modifiable structures of data with labelled fields. We use the ``type`` keyword to define a new record type for the user controls:

{% highlight haskell %}
type Controls = { -- define the user controls
    tilePushDirection: Direction  -- the direction the user wants to 
                                  -- slide the grid
  , newGameButtonPressed: Bool    -- whether the new game button is pressed
} 
{% endhighlight %}

We also define a new record type for all of the input:

{% highlight haskell %}
type Input = { -- define the inputs that the game will depend upon:
    controls: Controls          -- the user controls
  , randomFloats: [Float]       -- a source of randomness
}
{% endhighlight %}

The syntax for defining record types is fairly self-explanatory, but for more information, see [here](http://elm-lang.org/learn/Records.elm).

#### Player Controls

We now need to define a signal that represents the direction that the user is choosing to represent. We want to be able to use both the arrow keys and the wasd keys, and luckily elm's ``Keyboard`` library provides two signals that represent these keys: ``Keyboard.arrows`` and ``Keyboard.wasd``. These functions return a signal of a record in the format ``{x: Int, y: Int}`` taking the obvious values: e.g. if the left arrow or a key is pressed, ``{x=-1,y=0}``, or if the up arrow or w key is pressed, ``{x=0,y=1}``, or if both are pressed, ``{x=-1,y=1}``.

Making use of elm's [multi-way if syntax](http://elm-lang.org/learn/Syntax.elm#conditionals), we define a function to convert the values from these signals into a ``Direction``, and then feed the signals themselves into that function. The result is a signal of the direction that the player is choosing:

{% highlight haskell %}
playerDirection : Signal Direction -- make a signal that is the direction 
                                 -- that the user has chosen. compatible
                                 -- with both the wasd and arrow keys
playerDirection = let toDirection ds  = 
                      if | ds == {x=0,y=1} -> Up
                         | ds == {x=0,y=-1} -> Down
                         | ds == {x=1,y=0} -> Right
                         | ds == {x=-1,y=0} -> Left
                         | otherwise -> None
    in merge (toDirection <~ Keyboard.arrows) (toDirection <~ Keyboard.wasd)
{% endhighlight %}

Here we're making use of elm's ``merge`` function that combines the events from two signals.

#### Randomness

We will now define our souce of random floats. To do this, we will need a few new functions. The first is ``constant``, which simply provides an unchanging signal of the value that it is applied to, so ``constant "foo"`` is a signal that has the value ``"foo"`` and does not change.

The second function we require is ``sampleOn``, of type ``Signal a -> Signal b -> Signal b``. ``sampleOn s t`` provides a signal which has a new event every time ``s`` has a new event, and the value of the signal after each event is the value of ``t`` at the time of that event.

The last function is provided by elm's ``Random`` library: ``Random.floatList``, of type ``Signal Int -> Signal [Float]``. ``Random.floatList n`` provides a list of floats that changes every time n has an event. The length of the list is equal to the value held by n at each event.

Using these together, we can construct the signal we require:

{% highlight haskell %}
randomFloats : Signal a -> Signal [Float] -- provide two random floats that 
                                          -- will be used for random events in 
                                          -- the game logic. changes every time
                                          -- the signal s changes
randomFloats s = Random.floatList <| sampleOn s <| constant 4
{% endhighlight %}

We take a constant signal that holds a value 4, and sample it every time an event occurs in ``s``. Then we apply ``Random.floatlist`` to this signal, and thus obtain a signal holding a list of four floats, the values of which are randomised every time an event occurs on ``s``. We leave this as a function of ``s`` because we want to be able to control when the floats change.

And that's our input model! The final file for ``InputModel.elm`` is as follows:

{% highlight haskell %}
-- InputModel.elm
module InputModel where

import Keyboard
import Random

data Direction = Up | Down | Left | Right | None -- the direction to shift 
                                                 -- the grid

type Controls = { -- define the user controls
    tilePushDirection: Direction  -- the direction the user wants to 
                                  -- slide the grid
  , newGameButtonPressed: Bool    -- whether the new game button is pressed
} 

type Input = { -- define the inputs that the game will depend upon:
    controls: Controls          -- the user controls
  , randomFloats: [Float]       -- a source of randomness
}

{------------------------------------------------------------------------------
                               Player controls
------------------------------------------------------------------------------}

playerDirection : Signal Direction -- make a signal that is the direction 
                                 -- that the user has chosen. compatible
                                 -- with both the wasd and arrow keys
playerDirection = let toDirection ds  = 
                      if | ds == {x=0,y=1} -> Up
                         | ds == {x=0,y=-1} -> Down
                         | ds == {x=1,y=0} -> Right
                         | ds == {x=-1,y=0} -> Left
                         | otherwise -> None
    in merge (toDirection <~ Keyboard.arrows) (toDirection <~ Keyboard.wasd)

{------------------------------------------------------------------------------
                                Random data
------------------------------------------------------------------------------}

randomFloats : Signal a -> Signal [Float] -- provides four random floats that 
                                          -- will be used for random events in 
                                          -- the game logic. changes every time
                                          -- the signal s changes
randomFloats s = Random.floatList <| sampleOn s <| constant 4
{% endhighlight %}

### Game Model

Next we need to define the game model, and create a few basic functions that we can use to manipulate it. We start a new file ``GameModel.elm`` in the usual way:

{% highlight haskell %}
-- GameModel.elm
module GameModel where
{% endhighlight %}

We will need to use the list index operator and transpose function, so we shall import them from the ``Utils`` module:

{% highlight haskell %}
import Utils ((!), transpose)
{% endhighlight %}

There are two types of objects in 2048: 

1. The tiles, which can be either empty or contain a number.
2. The grid containing the tiles.

We define two new data types for these objects, representing a grid as a list of lists of tiles, where each list is a row of the grid:

{% highlight haskell %}
data Tile = Number Int | Empty -- a tile can either contain an int, or be empty
data Grid = Grid [[Tile]] -- a grid is a list of lists of tiles
{% endhighlight %}

We will also need a type of data to indicate what stage the game is at. A game can be either in progress, at game over, or won:

{% highlight haskell %}
data Progress = InProgress | GameOver | Won -- a game can be in progress, 
                                            -- at game over, or won
{% endhighlight %}

Finally we will need a data structure that represents the state of the game at any given point in time. The state of a game consists of the grid of tiles, the player's score, and the progress of the game. We will use a record to contain this data:

{% highlight haskell %}
type GameState = { -- defines the various properties of a game state:
    grid: Grid              -- the grid of tiles
  , score: Int              -- the score
  , gameProgress: Progress  -- the progress of the game (in progress, 
                            -- game over etc.)
}
{% endhighlight %}

Note that we are not importing anything from the ``InputModel`` module. It is important that the game model and the input model stay seperate.

We'll now define the size of the grid, i.e. the length of its sides. In the standard game of 2048, this number is 4.

{% highlight haskell %}
gridSize : Int -- the length of the sides of the grid
gridSize = 4
{% endhighlight %}

We could not do this and instead just assume that the grids have four tiles to a row when writing the rest of our code, but doing things this way will make the project easier to maintain and modify. For more information, see [this](http://stackoverflow.com/questions/47882/what-is-a-magic-number-and-why-is-it-bad) Stack Overflow question on the topic of magic numbers.

#### Grid Manipulation

We need to be able to get and set tiles in a grid. The function to read a tile at a location is easy:

{% highlight haskell %}
readTile : (Int, Int) -> Grid -> Tile -- the tile at (i,j) in a grid
readTile (i, j) (Grid g) = (g ! j) ! i
{% endhighlight %}

The function to set a tile is slightly more complex, but you should be able to follow the code:

{% highlight haskell %}
setTile : (Int, Int) -> Grid -> Tile -> Grid -- change the tile at (i,j) in 
                                             -- a grid
setTile (i, j) (Grid g) t = let 
        r = g ! j -- jth row
        nr = (take i r) ++ [t] ++ (drop (i+1) r) -- ith element changed in
                                                 -- jth row
    in Grid <| (take j g) ++ [nr] ++ (drop (j+1) g) -- new grid with modified 
                                                    -- jth row
{% endhighlight %}

We also need to convert between a tile and the number it represents. We will take an empty tile to represent 0.

{% highlight haskell %}
tileToInt : Tile -> Int -- convert a tile to the int it represents
tileToInt t = case t of
    Number n -> n
    otherwise -> 0

intToTile : Int -> Tile -- convert an int to a tile representing it
intToTile n = case n of
    0 -> Empty
    otherwise -> Number n
{% endhighlight %}

It will be useful to have a function for rotating the grid:

{% highlight haskell %}
rotateGrid : Grid -> Grid -- rotate a grid clockwise by 90 degrees 
rotateGrid (Grid g) = Grid <| map reverse <| transpose g
{% endhighlight %}

To understand this function, consider how each of ``map reverse`` and ``transpose`` will act on the grid. ``map reverse`` reflects the grid across the vertical line through it, and ``transpose`` reflects the grid across the diagonal from the top left corner to the bottom right corner. Using the mathematical fact that the composition of two reflections is a rotation, we can see why this works. The rotation in this case happens to be that of a clockwise rotation by 90 degrees.

#### The initial gamestate

The initial gamestate is the state of the game immediately after the compiled elm has been loaded, before any input has occured. In the case of 2048, this means an empty grid, a score of 0, and the game is in progress:

{% highlight haskell %}
emptyGrid : Grid -- a grid of empty tiles
emptyGrid = Grid <| repeat gridSize <| repeat gridSize <| Empty

defaultGame : GameState -- the default starting game state:
defaultGame = { 
    grid = emptyGrid            -- an empty grid
  , score = 0                   -- initial score is zero
  , gameProgress = InProgress   -- the game is in progress
}
{% endhighlight %}

And with that we have described and provided functions for the entire game model. The entire text of ``GameModel.elm`` is as follows: 

{% highlight haskell %}
--GameModel.elm
module GameModel where

import Utils ((!))

data Tile = Number Int | Empty -- a tile can either contain an int, or be empty
data Grid = Grid [[Tile]] -- a grid is a list of lists of tiles

data Progress = InProgress | GameOver | Won -- a game can be in progress, 
                                            -- at game over, or won

type GameState = { -- defines the various properties of a game state:
    grid: Grid              -- the grid of tiles
  , score: Int              -- the score
  , gameProgress: Progress  -- the progress of the game (in progress, 
                            -- game over etc.)
}

gridSize : Int -- the length of the sides of the grid
gridSize = 4

{------------------------------------------------------------------------------
                             Grid manipulation
------------------------------------------------------------------------------}

readTile : (Int, Int) -> Grid -> Tile -- the tile at (i,j) in a grid
readTile (i, j) (Grid g) = (g ! j) ! i

setTile : (Int, Int) -> Grid -> Tile -> Grid -- change the tile at (i,j) in 
                                             -- a grid
setTile (i, j) (Grid g) t = let 
        r = g ! j -- jth row
        nr = (take i r) ++ [t] ++ (drop (i+1) r) -- ith element changed in
                                                 -- jth row
    in Grid <| (take j g) ++ [nr] ++ (drop (j+1) g) -- new grid with modified 
                                                    -- jth row

tileToInt : Tile -> Int -- convert a tile to the int it represents
tileToInt t = case t of
    Number n -> n
    otherwise -> 0

intToTile : Int -> Tile -- convert an int to a tile representing it
intToTile n = case n of
    0 -> Empty
    otherwise -> Number n

rotateGrid : Grid -> Grid -- rotate a grid clockwise by 90 degrees 
rotateGrid (Grid g) = Grid <| map reverse <| transpose g

{------------------------------------------------------------------------------
                             Initial gamestate
------------------------------------------------------------------------------}

emptyGrid : Grid -- a grid of empty tiles
emptyGrid = Grid <| repeat gridSize <| repeat gridSize <| Empty

defaultGame : GameState -- the default starting game state:
defaultGame = { 
    grid = emptyGrid            -- an empty grid
  , score = 0                   -- initial score is zero
  , gameProgress = InProgress   -- the game is in progress
}
{% endhighlight %}


### Rendering

So far, ignoring the signals we described in the input model, everything we have done has been well within the scope of Haskell's capabilities. In fact, you could argue that it would have been easier to do with Haskell, given the fact that elm is a fairly new language and so is not as developed as Haskell.

But now it is time to write the code that will render our game. The facility to do this is a primary function of elm.

We set up a new file ``Rendering.elm``, and import all of the types for the gamestate that we are displaying from the ``GameModel`` module.

{% highlight haskell %}
-- Rendering.elm
module Rendering where

import GameModel (
    Tile
  , Number
  , Empty
  , Grid
  , gridSize
  , GameState
  , GameOver
  , Won
  )
{% endhighlight %}

#### Displaying a tile

First we'll define a few constants that describe the appearance of the tiles:

{% highlight haskell %}
tileSize : Float -- the width of a tile
tileSize = 106.25

tileMargin : Float -- the width of the gaps between tiles
tileMargin = 15

tileColor : Tile -> Color -- the color of a tile
tileColor tile = case tile of
                  Number 2 -> rgb 238 228 218
                  Number 4 -> rgb 237 224 200
                  Number 8 -> rgb 242 177 121
                  Number 16 -> rgb 245 149 99
                  Number 32 -> rgb 246 124 95
                  Number 64 -> rgb 246 94 59
                  Number 128 -> rgb 237 207 114
                  Number 256 -> rgb 237 204 97
                  Number 512 -> rgb 237 200 80
                  Number 1024 -> rgb 237 197 63
                  Number 2048 -> rgb 237 194 46
                  otherwise -> rgba 238 228 218 0.35 -- empty tile

tileTextColor : Tile -> Color -- the text color of a tile
tileTextColor tile = case tile of 
                  Number n -> if n >= 8 then (rgb 249 246 242) 
                                else (rgb 119 110 101)
                  otherwise -> black -- empty tile

tileTextSize : Tile -> Float -- the text size of a tile
tileTextSize tile = case tile of 
                  Number 128 -> 45
                  Number 256 -> 45
                  Number 512 -> 45
                  Number 1024 -> 35
                  Number 2048 -> 35
                  otherwise -> 55 -- empty tile

tileTextStyle : Tile -> Style -- the text style of a tile
tileTextStyle tile = {
                  typeface = [ "Helvetica Neue", "Arial", "sans-serif" ]
                , height = Just <| tileTextSize tile
                , color = tileTextColor tile
                , bold = True
                , italic = False
                , line = Nothing
                }
{% endhighlight %}

The ``rgb`` and ``rgba`` functions provide a ``Color``, elm's color type, for given levels of red, green, blue and, in the case of the latter, alpha level or opacity. The ``Style`` record is used by elm to describe the various styles of text that is being rendered.

(In case you're wondering, I was feeling uncreative, and so these values come straight from the original 2048. Feel free to mix it up with colors and fonts of your own.)

There are two main objects used for rendering in elm: *elements*, and *forms*. Elements are easily stackable objects that can be rendered. Forms are irregular objects that do not stack easily. For a better explanation of the difference between the two, see [here](http://elm-lang.org/learn/courses/beginner/Graphics.elm).

We need a function that will take a tile and return an element that is the tile rendered. A tile consists of:

1. A square colored background.
2. If the tile is not empty, a number that displays its value.

Elm provides a function ``collage`` that takes a width, a height, and a list of forms, and returns an element composed of those forms. We use this function, along with several others like ``square``, ``filled`` and ``centered`` whose functions should be obvious, to write a function that displays a tile (that is, converts a tile to an element):

{% highlight haskell %}
displayTile : Tile -> Element -- display a tile
displayTile tile = let tileBackground = filled (tileColor tile) 
                                        <| square tileSize
                in case tile of 
                    Number n -> collage (round tileSize) (round tileSize) 
                       [ 
                         tileBackground -- the tile background
                       , toForm <| centered  -- and the number
                                <| style (tileTextStyle tile) 
                                <| toText <| show n
                       ]
                    Empty -> collage (round tileSize) (round tileSize) 
                       [ tileBackground ] -- just the background
{% endhighlight %}

#### Displaying a grid of tiles

We want to be able to display a positioned tile, where its position is based on its coordinates in the grid. Elm takes the origin to be at the center, so after a little bit of very basic geometry we can come up with the following function:

{% highlight haskell %}
displayTileAtCoordinates : (Tile, Int, Int) -> Form
displayTileAtCoordinates (t,i,j) = let position = 
                        (
                          (tileSize + tileMargin) * (toFloat i - (toFloat gridSize - 1)/2)
                        , (-1) * (tileSize + tileMargin) * (toFloat j - (toFloat gridSize - 1)/2)
                        )
                    in move position <| toForm <| displayTile t
{% endhighlight %}

We are returning a form so that we can use the result of this function with ``collage``. Note that we multiply the y coordinate by minus one. This is because elm takes the positive direction on the y axis to be upwards, but I prefer to think with the positive direction downwards. This is simply a matter of personal preference.

We define the width of the grid based on ``tileWidth`` and ``tileMargin``:

{% highlight haskell %}
gridWidth : Float -- the width of the entire game grid
gridWidth = (toFloat gridSize) * tileSize + (1 + toFloat gridSize) * tileMargin
{% endhighlight %}

Now we define a function that displays a grid by using ``collage`` on a background square, and a list of the displayed tiles at their coordinates:

{% highlight haskell %}
displayGrid : Grid -> Element -- display a grid
displayGrid (Grid ts) = let
                    gridBox = filled (rgb 187 173 160) -- the grid background
                                <| square gridWidth
                    tiles = map displayTileAtCoordinates 
                        <| concat -- a list of the tiles with their row and 
                                  -- column coordinates
                        <| zipWith (\j r -> map (\(t,i) -> (t,i,j)) r) 
                            [0..(gridSize-1)] 
                                -- the tiles with row and column 
                                -- coordinates attached
                        <| map (\r -> zip r [0..(gridSize-1)]) -- the tiles 
                                                    -- with a row coordinate
                                                    -- coordinate attached
                        <| ts -- the tiles
    in collage (round gridWidth) (round gridWidth) ([gridBox] ++ tiles)
{% endhighlight %}

The code to calculate the list of displayed tiles may be overwhelming at first, but all it is some functional programming-fu to connect each tile in a list of lists with its row and column coordinates. There may be a more elegant way to do this, but I have been unable to come up with one. If you can, let me know!

#### Displaying overlay messages

We will want to display messages over the top of our game for when the player has won, or when the game is at game over. The overlay messages will consist of a square colored background the size of the grid, and a centered message. 

First we write a function to display a general overlay for a given text style, color, and message:

{% highlight haskell %}
displayOverlay : Style -> Color -> String ->  Element -- display an overlay 
                                                      -- with a message
displayOverlay s c t = collage (round gridWidth) (round gridWidth)
    [ 
      filled c <| square gridWidth -- background
    , toForm <| centered <| style s <| toText t -- message
    ]
{% endhighlight %}

Now we'll define the parameters for the game over and victory overlays. We are fortunate in that the text style for the game over overlay is the same as that of a 2 tile, and the text style for the victory overlay is the same as that of a 16 tile.

{% highlight haskell %}
gameOverOverlayStyle : Style
gameOverOverlayStyle = tileTextStyle <| Number 2

wonOverlayStyle : Style
wonOverlayStyle = tileTextStyle <| Number 16

gameOverOverlayColor : Color
gameOverOverlayColor = rgba 238 228 218 0.73

wonOverlayColor : Color
wonOverlayColor = rgba 237 194 46 0.5

gameOverMessage : String
gameOverMessage = "Game over!"

wonMessage : String
wonMessage = "You won!"
{% endhighlight %}

Now we can build the overlays:

{% highlight haskell %}
displayGameOverOverlay : Element -- display a game over overlay
displayGameOverOverlay = displayOverlay 
                            gameOverOverlayStyle
                            gameOverOverlayColor
                            gameOverMessage

displayWonOverlay : Element -- display a game won overlay
displayWonOverlay = displayOverlay 
                            wonOverlayStyle
                            wonOverlayColor
                            wonMessage
{% endhighlight %}

Finally we create a function to apply an overlay to a grid:

{% highlight haskell %}
applyOverlay : Element -> Element -> Element
applyOverlay overlay grid = collage (round gridWidth) (round gridWidth)
        [
          toForm <| grid
        , toForm <| overlay
        ]
{% endhighlight %}

#### Displaying the entire gamestate

After all of the work that we put into the above sections, actually displaying the game is comparatively easy. All we have to do is display the grid, and then if necessary apply one of the two overlays to it.

{% highlight haskell %}
display : GameState -> Element -- display a gamestate
display gameState = (case gameState.gameProgress of
                        GameOver -> applyOverlay displayGameOverOverlay
                        Won -> applyOverlay displayWonOverlay
                        otherwise -> id)
                    <| displayGrid gameState.grid
{% endhighlight %}

Note how we are taking advantage of first-class functions here. We are able to use the ``case`` notation to choose a function based on a set of conditions, and then apply that function to the displayed grid.

And that's our rendering done. The full content of ``Rendering.elm`` is as follows:

{% highlight haskell %}
-- Rendering.elm
module Rendering where

import GameModel (
    Tile
  , Number
  , Empty
  , Grid
  , gridSize
  , GameState
  , GameOver
  , Won
  )

{------------------------------------------------------------------------------
                              Displaying a tile
------------------------------------------------------------------------------}

tileSize : Float -- the width of a tile
tileSize = 106.25

tileMargin : Float -- the width of the gaps between tiles
tileMargin = 15

tileColor : Tile -> Color -- the color of a tile
tileColor tile = case tile of
                  Number 2 -> rgb 238 228 218
                  Number 4 -> rgb 237 224 200
                  Number 8 -> rgb 242 177 121
                  Number 16 -> rgb 245 149 99
                  Number 32 -> rgb 246 124 95
                  Number 64 -> rgb 246 94 59
                  Number 128 -> rgb 237 207 114
                  Number 256 -> rgb 237 204 97
                  Number 512 -> rgb 237 200 80
                  Number 1024 -> rgb 237 197 63
                  Number 2048 -> rgb 237 194 46
                  otherwise -> rgba 238 228 218 0.35 -- empty tile

tileTextColor : Tile -> Color -- the text color of a tile
tileTextColor tile = case tile of 
                  Number n -> if n >= 8 then (rgb 249 246 242) 
                                else (rgb 119 110 101)
                  otherwise -> black -- empty tile

tileTextSize : Tile -> Float -- the text size of a tile
tileTextSize tile = case tile of 
                  Number 128 -> 45
                  Number 256 -> 45
                  Number 512 -> 45
                  Number 1024 -> 35
                  Number 2048 -> 35
                  otherwise -> 55 -- empty tile

tileTextStyle : Tile -> Style -- the text style of a tile
tileTextStyle tile = {
                  typeface = [ "Helvetica Neue", "Arial", "sans-serif" ]
                , height = Just <| tileTextSize tile
                , color = tileTextColor tile
                , bold = True
                , italic = False
                , line = Nothing
                }

displayTile : Tile -> Element -- display a tile
displayTile tile = let tileBackground = filled (tileColor tile) 
                                        <| square tileSize
                in case tile of 
                    Number n -> collage (round tileSize) (round tileSize) 
                       [ 
                         tileBackground -- the tile background
                       , toForm <| centered  -- and the number
                                <| style (tileTextStyle tile) 
                                <| toText <| show n
                       ]
                    Empty -> collage (round tileSize) (round tileSize) 
                       [ tileBackground ] -- just the background

{------------------------------------------------------------------------------
                          Displaying a grid of tiles
------------------------------------------------------------------------------}

displayTileAtCoordinates : (Tile, Int, Int) -> Form
displayTileAtCoordinates (t,i,j) = let position = 
                        (
                          (tileSize + tileMargin) 
                             * (toFloat i - (toFloat gridSize - 1)/2)
                        , (-1) * (tileSize + tileMargin) 
                             * (toFloat j - (toFloat gridSize - 1)/2)
                        )
                    in move position <| toForm <| displayTile t

gridWidth : Float -- the width of the entire game grid
gridWidth = (toFloat gridSize) * tileSize + (1 + toFloat gridSize) * tileMargin

displayGrid : Grid -> Element -- display a grid
displayGrid (Grid ts) = let
                    gridBox = filled (rgb 187 173 160) -- the grid background
                                <| square gridWidth
                    tiles = map displayTileAtCoordinates 
                        <| concat -- a list of the tiles with their row and 
                                  -- column coordinates
                        <| zipWith (\j r -> map (\(t,i) -> (t,i,j)) r) 
                            [0..(gridSize-1)] 
                                -- the tiles with row and column 
                                -- coordinates attached
                        <| map (\r -> zip r [0..(gridSize-1)]) -- the tiles 
                                                    -- with a row coordinate
                                                    -- coordinate attached
                        <| ts -- the tiles
    in collage (round gridWidth) (round gridWidth) ([gridBox] ++ tiles)

{------------------------------------------------------------------------------
                         Displaying overlay messages
------------------------------------------------------------------------------}

displayOverlay : Style -> Color -> String ->  Element -- display an overlay 
                                                      -- with a message
displayOverlay s c t = collage (round gridWidth) (round gridWidth)
    [ 
      filled c <| square gridWidth -- background
    , toForm <| centered <| style s <| toText t -- message
    ]

gameOverOverlayStyle : Style
gameOverOverlayStyle = tileTextStyle <| Number 2

wonOverlayStyle : Style
wonOverlayStyle = tileTextStyle <| Number 16

gameOverOverlayColor : Color
gameOverOverlayColor = rgba 238 228 218 0.73

wonOverlayColor : Color
wonOverlayColor = rgba 237 194 46 0.5

gameOverMessage : String
gameOverMessage = "Game over!"

wonMessage : String
wonMessage = "You won!"

displayGameOverOverlay : Element -- display a game over overlay
displayGameOverOverlay = displayOverlay 
                            gameOverOverlayStyle
                            gameOverOverlayColor
                            gameOverMessage

displayWonOverlay : Element -- display a game won overlay
displayWonOverlay = displayOverlay 
                            wonOverlayStyle
                            wonOverlayColor
                            wonMessage

applyOverlay : Element -> Element -> Element
applyOverlay overlay grid = collage (round gridWidth) (round gridWidth)
        [
          toForm <| grid
        , toForm <| overlay
        ]

{------------------------------------------------------------------------------
                            Displaying a game
------------------------------------------------------------------------------}

display : GameState -> Element -- display a gamestate
display gameState = (case gameState.gameProgress of
                        GameOver -> applyOverlay displayGameOverOverlay
                        Won -> applyOverlay displayWonOverlay
                        otherwise -> id)
                    <| displayGrid gameState.grid
{% endhighlight %}

### Game Logic

#### Tile sliding

#### Win and loss conditions

#### Random tile placement

#### Game stepping function

### Putting it all together

#### Ports and Inputs

#### Gamestate folding and display

#### Embedding in HTML

## Done!

