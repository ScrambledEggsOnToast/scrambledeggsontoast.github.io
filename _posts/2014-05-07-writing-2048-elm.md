---
layout: post
title: Writing a 2048 clone in elm
tags: 
    - unramblings
    - programming
toc: true
comments: true
---


Several weeks ago, I, along with the rest of the internet, discovered [2048](http://gabrielecirulli.github.io/2048/), a fascinating one player game based on powers of two. Although it has a simple premise, the game requires a complex set of carefully thought out non-linear strategies to win, in a way that makes it comparable to a Rubik's Cube, or the two player game Go.

There are many interesting mathematical questions one could ask about the game, both trivial and non-trivial. For example:

1. What is the least number of moves required to win?
1. What is the lowest possible score when the game is won?
1. What is the highest number of moves that can be carried out before a win?
1. What is the lowest possible score when the game is lost?
1. Is a win always guaranteed?

I intend to try to tackle some of these in another post. 

For now, I have applied my new found love for functional programming and created a clone of 2048 in elm. [Elm](http://elm-lang.org/) is a programming language based on Haskell that uses [Functional Reactive Programming](http://en.wikipedia.org/wiki/Functional_reactive_programming) to enable the creation of interactive applications, while keeping the language functional. 

Elm compiles to HTML, CSS and Javacript, and so is very easy to deploy &mdash; as a demonstration of this I have embedded the final product of this project below. Start a new game and give it a try!

<center><iframe style="border: none; width: 560px; height: 680px;" src="http://scrambledeggsontoast.github.io/2048-elm/build/"></iframe></center>

I decided to write up the project to serve as a resource and a tutorial of sorts for those trying to get into FRP or elm. I am still learning about these topics myself, so if you notice anything that has been done in a suboptimal way do let me know. Also, this is the first time I have written a post like this of any significant length, so feedback with regards to that is also welcome.

The project [is on GitHub](https://github.com/ScrambledEggsOnToast/2048-elm). Feel free to submit pull requests if you want to fix any bugs, or indeed for any other appropriate reason. 

## Prerequisites and references

I expect you to at least have a working knowledge of functional programming, and preferably in the context of Haskell. If you do not, [Learn You a Haskell for Great Good!](http://learnyouahaskell.com/) can be [read online](http://learnyouahaskell.com/chapters) and is an excellent beginner's guide. If you are not comfortable with functors, monads, etc., you should still be able to follow this tutorial. Those concepts are not used in this project, and are not explicitly used in elm in general.

I don't expect you to have used elm before. The general syntax in elm is very similar to that of Haskell, with a few key differences. Of importance is the fact that while in Haskell ``::`` is the 'has type of' symbol, and ``:`` is the cons operator, in elm ``:`` is the 'has type of' symbol, and ``::`` is the cons operator. Also, the function application operator in elm is ``<|``, not ``$`` as it is in Haskell. I will describe other differences as we encounter them. A useful syntax reference can be found [here](http://elm-lang.org/learn/Syntax.elm). 

The main difference in programming style between elm and Haskell is that elm uses *signals*, which are values that change with time. I will explain how these work and how to use them in the next section.

A key feature of elm is that an elm file can be compiled to a *component*, which can be embedded into an HTML document, and can communicate with Javascipt via *ports*. We will use take advantage of this in our project, but it does not matter if you are unfamiliar with HTML and Javascript, as they are not the focus.

If you have installed ``cabal-install``, elm can be installed with ``cabal install elm``. Compiling elm files is as easy as using ``elm Main.elm`` to generate a file ``build/Main.html``, which can be opened in a web browser. 

## Signals
Signals in elm are values that change with time. They are event-based, meaning changes in signals are discrete, and do not have to happen at regular intervals. 

Suppose we have a signal ``signal`` that holds the value ``"foo"``. We say that ``signal`` has type ``Signal String``. After five seconds an event arrives on ``signal``, changing its value to ``"bar"``. 

Now suppose we have a function ``question`` that appends ``"?"`` to a string. We cannot apply ``question`` directly to ``signal`` because ``question`` takes values that are strings, and ``signal`` is a signal of strings. How then do we apply a function to a signal?

The answer is to use ``lift``, a function provided by elm. ``lift`` takes a function of type ``a -> b`` and a signal of type ``Signal a``, and returns a signal of type ``Signal b``. This signal is what you might expect: for each event in the signal of type ``Signal a``, the function of type ``a -> b`` is applied to the value of the signal after that event, and the result of this is made the value of a new event in the signal of type ``Signal b``.

So suppose we define a signal ``signalQuestioned = lift question signal``. We then have that the value held now by ``signalQuestioned`` is ``"foo?"``, and in five seconds an event will arrive on the signal that will change the value it holds to ``"bar?"``.

Elm provides infix operators to make this easier to read and type. ``lift question signal`` is equivalent to ``question <~ signal``, read as "``signal`` fed into ``question``". If we have a function that takes more than one parameter we can use ``~`` to feed a series of signals of the parameters into the function as follows: ``function <~ signal1 ~ signal2 ~ signal3``. For more information on how this works, see
[here](http://elm-lang.org/blog/announce/0.7.elm#do-you-even-lift).

## Definition of the game

The board on which 2048 is played is a 4 by 4 grid of tiles. Tiles can either be empty, or contain an integer number that is a power of two. The initial board contains two random tiles in random positions. Each of these tiles has a 90% probability of being a 2, and a 10% probability of being a 4.

At any time, the player has the option to slide all of the tiles in the grid in one of four directions: up, down, left or right. The tiles slide naturally as expected, filling empty tiles with tiles that contain numbers, but also have an additional behaviour. If there are two adjacent non-empty tiles (in the direction of the slide) that hold the same value, then those two tiles merge together, forming a new tile whose value is the sum of the original two. The new tile's value is
added to the score. If there are more than two adjacent non-empty tiles holding the same value, this pairing is prioritised to be between those most in the direction specified &mdash; so sliding a grid with a row \\([2,2,2,8]\\) to the left would result in \\([4,2,8,0]\\), whereas sliding it to the right would result in \\([0,2,4,8]\\). 

After each slide, a new random tile (again being a 2 with 90% probability, and being a 4 with 10% probability) is placed in one of the remaining empty tile positions.

The game ends in one of two ways. If one of the tiles in the grid has the value 2048, then the game is won. If the grid is full of tiles, and no slides in any direction will alter the grid any further, then the game is lost. The win condition holds precedence over the loss condition.

## To the text editor!

### Input Model

When I refer to the input, I mean all of the information that causes the code to run differently each time. So for example input is not just limited to using the keyboard, but can also mean a source of random data. 

Our first task is to model the input for the game. We create a new file ``InputModel.elm`` and define its module:

{% highlight haskell %}
-- InputModel.elm
module InputModel where
{% endhighlight %}

We will need to make use of both keyboard input and a source of random numbers, so we import their respective libraries:

{% highlight haskell %}
import Keyboard
import Random
{% endhighlight %}

There are three inputs in the game: 

1. The controls that the player changes, i.e. the direction for a slide.
1. The state of the button to initiate a new game.
1. Two pairs of two random floats, one for choosing a random tile value, and the other for choosing a random tile location. We need two pairs for the beginning of a new game, when we place two tiles.

First we define a new data type for the direction of a slide:

{% highlight haskell %}
data Direction = Up | Down | Left | Right | None -- the direction to shift the grid
{% endhighlight %}

We need a way to store all of the input information in a single data structure. One of elm's features is its implementation of records, which are essentially easily modifiable structures of data with labelled fields. We use the ``type`` keyword to define a new record type for the user controls:

{% highlight haskell %}
type Controls = { -- define the user controls
    tilePushDirection: Direction  -- the direction the user wants to 
                                  -- slide the grid
  , newGameButtonPressed: Bool    -- whether the new game button is pressed
} 
{% endhighlight %}

We also define a new record type for all of the input:

{% highlight haskell %}
type Input = { -- define the inputs that the game will depend upon:
    controls: Controls          -- the user controls
  , randomFloats: [Float]       -- a source of randomness
}
{% endhighlight %}

The syntax for defining record types is fairly self-explanatory, but for more information, see [here](http://elm-lang.org/learn/Records.elm).

#### Player Controls

We now need to define a signal that represents the direction that the user is choosing to represent. We want to be able to use both the arrow keys and the wasd keys, and luckily elm's ``Keyboard`` library provides two signals that represent these keys: ``Keyboard.arrows`` and ``Keyboard.wasd``. These functions return a signal of a record in the format ``{x: Int, y: Int}`` taking the obvious values: e.g. if the left arrow or a key is pressed, ``{x=-1,y=0}``, or if the up arrow or w key is pressed, ``{x=0,y=1}``, or if both are pressed, ``{x=-1,y=1}``.

Making use of elm's [multi-way if syntax](http://elm-lang.org/learn/Syntax.elm#conditionals), we define a function to convert the values from these signals into a ``Direction``, and then feed the signals themselves into that function. The result is a signal of the direction that the player is choosing:

{% highlight haskell %}
playerDirection : Signal Direction -- make a signal that is the direction 
                                 -- that the user has chosen. compatible
                                 -- with both the wasd and arrow keys
playerDirection = let toDirection ds  = 
                      if | ds == {x=0,y=1} -> Up
                         | ds == {x=0,y=-1} -> Down
                         | ds == {x=1,y=0} -> Right
                         | ds == {x=-1,y=0} -> Left
                         | otherwise -> None
    in merge (toDirection <~ Keyboard.arrows) (toDirection <~ Keyboard.wasd)
{% endhighlight %}

Here we're making use of elm's ``merge`` function that combines the events from two signals.

#### Randomness

We will now define our souce of random floats. To do this, we will need a few new functions. The first is ``constant``, which simply provides an unchanging signal of the value that it is applied to, so ``constant "foo"`` is a signal that has the value ``"foo"`` and does not change.

The second function we require is ``sampleOn``, of type ``Signal a -> Signal b -> Signal b``. ``sampleOn s t`` provides a signal which has a new event every time ``s`` has a new event, and the value of the signal after each event is the value of ``t`` at the time of that event.

The last function is provided by elm's ``Random`` library: ``Random.floatList``, of type ``Signal Int -> Signal [Float]``. ``Random.floatList n`` provides a list of floats that changes every time n has an event. The length of the list is equal to the value held by n at each event.

Combining these we construct the signal we require:

{% highlight haskell %}
randomFloats : Signal a -> Signal [Float] -- provide two random floats that 
                                          -- will be used for random events in 
                                          -- the game logic. changes every time
                                          -- the signal s changes
randomFloats s = Random.floatList <| sampleOn s <| constant 4
{% endhighlight %}

We leave this as a function because we want to be able to control when the floats change.

And that's our input model! The final file for ``InputModel.elm`` is as follows:

{% highlight haskell %}
-- InputModel.elm
module InputModel where

import Keyboard
import Random

data Direction = Up | Down | Left | Right | None -- the direction to shift 
                                                 -- the grid

type Controls = { -- define the user controls
    tilePushDirection: Direction  -- the direction the user wants to 
                                  -- slide the grid
  , newGameButtonPressed: Bool    -- whether the new game button is pressed
} 

type Input = { -- define the inputs that the game will depend upon:
    controls: Controls          -- the user controls
  , randomFloats: [Float]       -- a source of randomness
}

{------------------------------------------------------------------------------
                               Player controls
------------------------------------------------------------------------------}

playerDirection : Signal Direction -- make a signal that is the direction 
                                 -- that the user has chosen. compatible
                                 -- with both the wasd and arrow keys
playerDirection = let toDirection ds  = 
                      if | ds == {x=0,y=1} -> Up
                         | ds == {x=0,y=-1} -> Down
                         | ds == {x=1,y=0} -> Right
                         | ds == {x=-1,y=0} -> Left
                         | otherwise -> None
    in merge (toDirection <~ Keyboard.arrows) (toDirection <~ Keyboard.wasd)

{------------------------------------------------------------------------------
                                Random data
------------------------------------------------------------------------------}

randomFloats : Signal a -> Signal [Float] -- provides four random floats that 
                                          -- will be used for random events in 
                                          -- the game logic. changes every time
                                          -- the signal s changes
randomFloats s = Random.floatList <| sampleOn s <| constant 4
{% endhighlight %}


### Game Model

#### Grid Manipulation

#### The initial gamestate

### Rendering

#### Displaying a tile

#### Displaying a grid of tiles

#### Displaying overlay messages

#### Displaying the entire game

### Game Logic

#### Tile sliding

#### Win and loss conditions

#### Random tile placement

#### Game stepping function

### Putting it all together

#### Ports and Inputs

#### Gamestate folding and display

#### Embedding in HTML

{% highlight haskell %}
module Elm2048 where

import Window

import InputModel (Input, controls, randomFloats)
import GameModel (defaultGame)
import Logic (stepGame)
import Rendering (display)

port score : Signal Int -- Outgoing score port
port score = (\x -> x.score) <~ gameState

port newGameButton : Signal Bool -- Incoming new game button port

delta = fps 30 -- a signal determining the rate at which the game steps
input = sampleOn delta -- sample the input every time an event occurs in delta
            <| Input 
            <~ controls 
             ~ (randomFloats delta) 
             ~ newGameButton 

gameState = foldp stepGame defaultGame input -- fold the input into the game 
                                             -- state, starting with the 
                                             -- default game state

main = display <~ Window.dimensions ~ gameState -- display the game
{% endhighlight %}

## Done!

